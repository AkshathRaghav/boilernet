
// void compute_fsm_process(
//     FILE                   *sd_file,             // opened in START_COMPUTE
//     const char             *result_filename,     // e.g. "image123.png_results.txt"
//     int                      num_blades,
//     spi_device_handle_t    *blade_handles,
//     const int             *blade_hs_pins,
//     uint8_t                *tx_buf,
//     uint8_t                *rx_buf,
//     TickType_t            *compute_start_tick,
//     compute_fsm_state_t   *compute_fsm_state,
//     fsm_state_t           *outer_fsm_state
// ) {
//     static int  current_blade = 0;
//     static FILE *result_file   = NULL;
//     const int   max_payload    = TRANSFER_SIZE - 3;  // reserve 3 bytes for header
//
//     #define TIMEOUT_MS   15000
//     #define CHECK_TIMEOUT() \
//         if ((xTaskGetTickCount() - *compute_start_tick) > pdMS_TO_TICKS(TIMEOUT_MS)) { \
//             ESP_LOGE(COMM_TAG, "Blade %d handshake timeout", current_blade);         \
//             *outer_fsm_state = FSM_ERROR;                                            \
//             return;                                                                  \
//         }

//     switch (*compute_fsm_state) {

//       // ── Fan-out the image to each blade ──
//       case FSM_SEND_DATA_TO_BLADE:
//       {
//         // rewind input file before the first blade
//         if (current_blade == 0) {
//             fseek(sd_file, 0, SEEK_SET);
//         }

//         if (current_blade < num_blades) {
//             // 1) wait for blade’s HS line
//             if (!gpio_get_level(blade_hs_pins[current_blade])) {
//                 CHECK_TIMEOUT();
//                 return; // try again next iteration
//             }

//             // 2) stream in DATA_TO_BLADE packets
//             int file_bytes;
//             do {
//                 file_bytes = sdcard_read(sd_file, &tx_buf[3], max_payload);
//                 if (file_bytes < 0) {
//                     ESP_LOGE(COMM_TAG, "Error reading file for compute send");
//                     *outer_fsm_state = FSM_ERROR;
//                     return;
//                 }
//                 tx_buf[0] = PACKET_TYPE_DATA_TO_BLADE;
//                 tx_buf[1] = (file_bytes >> 8) & 0xFF;
//                 tx_buf[2] = file_bytes & 0xFF;
//                 spi_transaction_t t = {
//                     .length    = (file_bytes + 3) * 8,
//                     .tx_buffer = tx_buf,
//                     .rx_buffer = NULL,
//                 };
//                 spi_device_transmit(blade_handles[current_blade], &t, portMAX_DELAY);

//             } while (file_bytes == max_payload);  

//             tx_buf[0] = PACKET_TYPE_END_DATA_TO_BLADE;
//             spi_transaction_t t_end = {
//                 .length    = 1 * 8,
//                 .tx_buffer = tx_buf,
//                 .rx_buffer = NULL
//             };
//             spi_device_transmit(blade_handles[current_blade], &t_end, portMAX_DELAY);

//             current_blade++;
//             // rewind if there’s another blade
//             if (current_blade < num_blades) {
//                 fseek(sd_file, 0, SEEK_SET);
//             }
//         }

//         // switch to collect phase once all blades have data
//         if (current_blade >= num_blades) {
//             *compute_start_tick   = xTaskGetTickCount();
//             current_blade         = 0;
//             *compute_fsm_state    = FSM_GET_DATA_FROM_BLADE;
//         }
//         break;
//       }

//       // ── Gather results back from each blade ──
//       case FSM_GET_DATA_FROM_BLADE:
//       {
//         if (current_blade == 0) {
//             // open the results file once
//             result_file = sdcard_open(result_filename, "w");
//             if (!result_file) {
//                 ESP_LOGE(COMM_TAG, "Cannot open result file %s", result_filename);
//                 *outer_fsm_state = FSM_ERROR;
//                 return;
//             }
//         }

//         if (current_blade < num_blades) {
//             // 1) wait for blade’s HS line
//             if (!gpio_get_level(blade_hs_pins[current_blade])) {
//                 CHECK_TIMEOUT();
//                 return;
//             }

//             // 2) initiate read
//             tx_buf[0] = PACKET_TYPE_START_DATA_FROM_BLADE;
//             spi_transaction_t t_start = {
//                 .length    = TRANSFER_SIZE * 8,
//                 .tx_buffer = tx_buf,
//                 .rx_buffer = rx_buf
//             };
//             spi_device_transmit(blade_handles[current_blade], &t_start, portMAX_DELAY);

//             // 3) parse header + payload
//             int data_len = (rx_buf[1] << 8) | rx_buf[2];
//             if (data_len < 0 || data_len > max_payload) {
//                 ESP_LOGE(COMM_TAG, "Invalid data length %d from blade %d", data_len, current_blade);
//                 *outer_fsm_state = FSM_ERROR;
//                 return;
//             }
//             size_t w = sdcard_write(result_file, &rx_buf[3], data_len);
//             if (w != (size_t)data_len) {
//                 ESP_LOGE(COMM_TAG, "Result write failed for blade %d", current_blade);
//                 *outer_fsm_state = FSM_ERROR;
//                 return;
//             }
//             ESP_LOGI(COMM_TAG, "Blade %d → %d bytes", current_blade, data_len);

//             // 4) ack
//             tx_buf[0] = PACKET_TYPE_END_DATA_FROM_BLADE;
//             spi_transaction_t t_ack = {
//                 .length    = 1 * 8,
//                 .tx_buffer = tx_buf,
//                 .rx_buffer = NULL
//             };
//             spi_device_transmit(blade_handles[current_blade], &t_ack, portMAX_DELAY);

//             current_blade++;
//         }

//         // done?
//         if (current_blade >= num_blades) {
//             sdcard_close(result_file);
//             result_file      = NULL;
//             current_blade    = 0;
//             *compute_fsm_state = FSM_IDLE;
//             ESP_LOGI(COMM_TAG, "All blade results written to %s", result_filename);
//         }
//         break;
//       }


//       default:
//         break;
//     }

//     #undef CHECK_TIMEOUT
//     #undef TIMEOUT_MS
// }